# KMP(Knuth-Morris-Pratt) 문자열 패턴 매칭 알고리즘 #

어떤 긴 문자열 S에 대해,  패턴 P = "aabaabac" 를 찾는다고 해 보자. **index는 0부터 시작**한다.

**비교하는 index를 i라 하자.** 그리고, 비교 연산을 수행한 끝에, i=0 ~ i=6 까지는 일치하고, i=7에서 불일치가 발생했다고 하자. 그러면, 기존의 naive한 문자열 매칭 알고리즘은 i=1에서 다시 비교를 시작하겠지만,

이보다 훨씬 효율적으로 탐색의 시작 위치를 변경할 수 있다. **지금까지 7개의 문자가 일치했다** 는 사실을 이용하는 것이다. 나도 그랬고, 당연히 이게 도데체 무슨 소리냐..라는 생각이 들 수 있지만, 차차 알아보자. 

## 부분 일치 테이블의 정의(pi배열, fail함수... 부르는 이름이 다양함)

부분 일치 테이블이란 뭘까..? 이를 알아보기 전에, naive한 알고리즘이 왜 비효율적인지 생각해 보자. 아마, **불일치가 발생했는데, 무조건 탐색 위치를 1씩만 옮겨서** 그런 것일 거다. 

이 위치로 이동시키면 맞을 가능성이 높은데? 라고 생각되는 위치로 바로 점프해 비교할 수만 있다면, 탐색 위치를 효율적으로 뛰어 넘으면서 naive한 방법보다 훨씬 효율적으로 비교를 할 수 있을 거다. 

그러면, 그걸 어떻게 할 수 있을까? 

우리가 찾고자 하는 패턴 P의 **모든 접두사들에 대해서, 그 접두사와 일치하는 가장 긴 접미사** 를 알고 있으면, 손쉽게 뛰어 넘을 수 있다. 예시를 살펴 보는 것이 이해하기에 도움이 되므로, P = "aabaabac" 의 상황을 살펴보자. 

i=7에서 불일치가 발생했다. 그 말은, i=0 ~ i=6까지, 7개의 문자는 지금 일치한다는 의미다. 이 상태에서, i=0 ~ i=6까지의 부분 문자열(aabaaba)에 대해, 가능한 모든 접두사와 일치하는 접미사 중 가장 길이가 긴 것을 찾아보자. 

문자열 "aabaaba"에 대해, 가능한 접두사는 a, aa, aab, aaba, aabaa, aabaab, aabaaba가 있다. 그런데, 여기서 패턴 P와 동일한 문자열인 aabaaba는 제외한다. 

그러면, 접두사 a, aa, aab, aaba, aabaa, aabaab에 대해서, a, aaba가, 접두사이면서 접미사이기도 하며, 이 중 가장 긴 친구는, aaba이고 그 길이는 4라는 사실을 알 수 있다. 그러면, 우리는 기존에, "aabaaba"까지는 일치했다는 것을

알고 있기에, i = 7에서 불일치가 발생한 현재 시점에서 i=1로 이동하는 것이 아니라, i=3으로 이동하면 된다. 어차피, "aabaaba"는 지금 **일치** 하고 있어서, i=3부터 **aaba**abac를 깔아도, 볼드체로 표시된 부분은 그냥 일치한다는 사실을 알 수 있다. 

다시 말하자면, 접두사와 접미사가 일치하는 시점에서, 접두사 위치에 있던 패턴을, 접미사 위치로 옮겨도, 어차피 **접두사와 접미사가 일치** 하므로, 원본 문자열 S와 비교해도, 일치한다는 것이다. 그리고, 우리는 이를 재귀적으로 반복할 수 있다. 

## 정리
몇 가지 표현을 정의하고, 이 과정을 정리해 보자. 

a) S[...i] = 문자열 S에 대해, index i까지의 접두사. 

b) S[i...j] = 문자열 S에 대해, index i부터, index j까지의 부분 문자열.

c) S[i...] = 문자열 S에 대해, index i부터, 문자열의 끝까지의 접미사. 

