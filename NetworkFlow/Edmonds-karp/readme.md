# Edmonds-Karp 알고리즘 #

**Prev : https://github.com/2e2guk/Algorithm/tree/main/NetworkFlow**

-> Edmonds-Karp 알고리즘은, 최대 유량을 구하는 Naive한 알고리즘을 최적화한 알고리즘이다. 이전의 글에서, Ford-Fulkerson 방법을 최적화하는데는 두 가지 방법이 있다고 했다. 

증가 경로를 빨리 찾던지, 현재 흘릴 수 있는 유량을 빨리 찾던지. 

 Edmonds-Karp 알고리즘은, 기존의 Ford-Fulkerson 방법보다, **효율적으로 증가 경로를 찾는다.** 어떻게...? 

이전 글에서, 증가 경로를 찾는 데는 크게 두 가지, DFS, BFS가 있다고 했다. 그런데, **BFS를 이용하는 것이, DFS를 이용하는 것보다 월등히 빠르다.**

왜일까? 어떤 책이든, BFS에 대해 공부하다 보면, "**BFS로 찾는 경로는 최단 경로임이 보장**되어 있다." 라는 말이 나온다. 본 기억이 있을 것이다. 

우리는, 소스->싱크로의 증가 경로를 찾을 것인데, **최단 증가 경로** 를 찾을 것이다. 일단, 새로운 자료구조를 하나 공부하자. 

###  Residual graph(잔여 그래프)상에서, 증가 경로를 찾는 횟수의 제한.

-> 이전의 글에서, Flow Network에는, 용량과 유량이 있고, 잔여 용량 이라는 것도 있다는 것을 알아봤다. 여기서, 우리는 

**어떤 간선 e에, 용량과 동일한 크기의 유량이 흐르면, 이 간선 e를 포화(Saturated)** 되었다고 한다.

그리고, 포화되지 않은 간선들로만 이루어진 그래프를, **Residual Graph** 라고 한다. 그러니까, **잔여 용량 > 0 인 간선들로만 그래프를 구성한, 원본 Flow Network의 부분 그래프** 이다.

앞에서 정의한 증가 경로의 정의에 따르면, Residual Graph 상에서, 소스-> 싱크로의 경로를 아무거나 하나 고르면, 이는 **증가 경로** 가 된다. 애초에 우리가 Residual Graph의 간선들을, 

잔여 용량 > 0인 간선들로 구성해 두었기 때문이다. 

그러면, 우리는 이 증가 경로로, 어떤 유량을 흘릴 거다. 그러면, **증가 경로에 포함된 간선 중 최소한 하나는 포화되고, 결국 이 간선은 Residual Graph에서 삭제**된다. 

왜? 포화된 간선의 잔여 용량은 0이기 때문이다. 그러면, 직관적으로 생각해서, 증가 경로 P에 대해서, 중간에 어떤 간선이 삭제되었는데, 이 삭제된 간선을 e라 하고, e를 기준으로 쪼개진 경로 2개를, P1, P2라고 하자.

그러면 **P = {P1 U e U P2}** 가 되는데, e가 날아갔다. P1, P2는 그대로 유지하면서, 기존의 P와 동일한 길이를 갖는 경로를 구성할 수 있을까? 불가능하다. **최소한 길이가 2는 늘어난다**. 

예를 들어 보자. 2023년 12월 23일 기준, 서울 지하철 노선도에, 3호선 교대역과, 양재역 사이를 보자. 사이엔 남부터미널역이 있지만, 남부터미널역은 무시한다.. 불의의 사고로, 교대역-> 양재역 사이의 기찻길이 막혔다. 

그러면, 교대역 -> 양재역으로 가려면, 교대역에서 2호선으로 갈아타서, 2호선 교대역 -> 강남역 -> 양재역 으로 가는 수밖에 없고, 길이가 최소 **2**는 늘어난다.

그러면, 우리는, **최단 경로를 D로 고정한다면, 한 번 증가 경로를 찾을 때마다, 최소한 1개의 간선이 포화 상태가 되기에, 최대 O(E)번의 증가 경로를 찾는다는 사실** 을 알 수 있다. 

그리고, 최단 경로의 길이는, 아무리 길어 봤자, V 이하이다. 그러면, 우리는 증가 경로를 최대한 많이 찾는다고 생각해도, **O(VE)번의 증가 경로만을 찾는다**. 
같이 참고하면 좋은 링크를 첨부한다.(https://koosaga.com/133)

## Edmonds-Karp 알고리즘의 수행. 

Edmonds-Karp 알고리즘은, 증가 경로를 이렇게 **Residual Graph상에서의 소스->싱크로의 최단 경로** 인 것을 선택함으로써, 빠르게 증가 경로를 구성하고, O(V*E^2) 시간에 최대 유량을 찾는다. 


**Next : https://github.com/2e2guk/Algorithm/tree/main/NetworkFlow/Dinic**
