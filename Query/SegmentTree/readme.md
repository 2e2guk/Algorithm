# Segment Tree #

segment tree, 세그먼트 트리는, 구간 트리라고도 불리며, 이진 트리의 형태를 띠고 있다. 저장된 자료들을 적절히 전처리해서, 그들에 대한 질의를 빠르게 처리하는 자료 구조이다. 

예를 들어서, Range Minimum Query(RMQ), 구간 최솟값 쿼리를 수행하는 상황을 생각해 보자.

배열 A = {1, 4, 5, 3, 7, 2, 4, 5} 를 생각해 보자. 이 배열에서, 구간 [0, 3] 원소들의 최솟값은 3이고, [3, 6]의 최솟값은 2이다. naive하게 구간의 최솟값을 구하는 것을 생각해 보면, 

그냥 주어진 구간을 직접 순회하며, 현재 최소인 원소를 들고 있다가, 만약 지금보다 더 작은 원소가 나오면 바로 갱신하는 작업을 통해서, 주어진 구간의 최솟값을 찾을 수 있다. 

그러면, 이 naive한 방법은, worst case에서의 시간 복잡도가 O(N) 임을 알 수 있다. 이 작업을 더 효율적이게 하기 위해서, segment tree라는 자료구조를 고안하게 되었다. 

핵심 아이디어는, **주어진 배열의 구간을 표현하는 이진 트리를 만드는 것** 이다. 이렇게 하고, 리프 노드는, 배열의 각 원소 자체를 포함한다. 

그리고, 부모 노드는, 자식 노드가 표현하는 구간을 합한 구간을 표현한다. 그러면, **루트 노드는, 배열 전체를 표현** 하게 될 것이다. 

그러면, 이렇개 표현한 segment tree에는 무엇이 들어가게 되냐? **쿼리의 결괏값** 이 들어가게 된다. 우리가 지금 보는 것은 RMQ이므로, 노드에는 최솟값이 들어가게 될 것이다. 

리프 노드부터, 루트 노드까지 올라가며, **자신의 두 자식 노드의 값 중 더 작은 값**을 자신의 노드에 넣는 것을 반복하며, 루트 노드까지 올라가고, 루트 노드의 값을 반환하면 끝이다. 

그러면, 시간 복잡도는, **O(log2 N)** 이 됨을, 어렵지 않게 알 수 있다. 

쿼리의 종류가 바뀌어도(ex. 주어진 구간의 원소들의 합을 구하는 쿼리), segment tree를 구성하는 과정은 달라지지 않는다(리프 노드는 배열의 값 자체, 자신의 자식 노드들의 합을 저장). 

Next : https://github.com/2e2guk/Algorithm/blob/main/Query/LazyPropagation/readme.md









